/**
 * Build script: Extracts SVG path data from wall mask files and outputs
 * an embedded TypeScript module. Run before next build to avoid fetching
 * SVGs at runtime (they would appear in Network tab).
 *
 * Usage: tsx scripts/generate-wall-masks.ts
 */

import * as fs from 'fs';
import * as path from 'path';

const PROJECT_ROOT = process.cwd();
const MANIFEST_PATH = path.join(PROJECT_ROOT, 'public', 'visualizerManifest.json');
const OUTPUT_PATH = path.join(PROJECT_ROOT, 'src', 'data', 'embeddedWallMasks.ts');

interface WallManifest {
  [wallKey: string]: string;
}

interface VariantManifest {
  name: string;
  label: string;
  mainImage: string;
  walls: WallManifest;
}

interface RoomManifest {
  roomType: string;
  label: string;
  variants: VariantManifest[];
}

function extractPathFromSvg(svgContent: string): string {
  // Try DOMParser-style regex: match d="..." or d='...'
  const pathMatch = svgContent.match(/<path[^>]*\sd=["']([^"']+)["'][^>]*>/i);
  if (pathMatch && pathMatch[1]) {
    return pathMatch[1].trim();
  }
  // Fallback: match any path with d attribute
  const allPaths = svgContent.matchAll(/<path[^>]*d=["']([^"']+)["'][^>]*>/gi);
  const first = allPaths.next();
  if (first.value && first.value[1]) {
    return first.value[1].trim();
  }
  return '';
}

function resolveSvgPath(urlPath: string): string {
  // /assets/images/... -> public/assets/images/...
  const relative = urlPath.startsWith('/') ? urlPath.slice(1) : urlPath;
  return path.join(PROJECT_ROOT, 'public', relative);
}

function main() {
  const manifestRaw = fs.readFileSync(MANIFEST_PATH, 'utf-8');
  const manifest: RoomManifest[] = JSON.parse(manifestRaw);

  const embedded: Record<string, Record<string, string>> = {};

  for (const room of manifest) {
    for (const variant of room.variants) {
      const masks: Record<string, string> = {};

      for (const [wallKey, svgUrl] of Object.entries(variant.walls)) {
        const filePath = resolveSvgPath(svgUrl);

        if (!fs.existsSync(filePath)) {
          console.warn(`[generate-wall-masks] SVG not found: ${filePath}`);
          continue;
        }

        const svgContent = fs.readFileSync(filePath, 'utf-8');
        const pathData = extractPathFromSvg(svgContent);

        if (pathData) {
          masks[wallKey] = pathData;
        } else {
          console.warn(`[generate-wall-masks] No path found in: ${filePath}`);
        }
      }

      if (Object.keys(masks).length > 0) {
        embedded[variant.name] = masks;
      }
    }
  }

  const output = `// Auto-generated by scripts/generate-wall-masks.ts - do not edit
// Run: tsx scripts/generate-wall-masks.ts (or npm run prebuild)

export const embeddedWallMasks: Record<string, Record<string, string>> = ${JSON.stringify(embedded, null, 2)};
`;

  const outputDir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_PATH, output, 'utf-8');
  console.log(`[generate-wall-masks] Wrote ${Object.keys(embedded).length} variants to ${OUTPUT_PATH}`);
}

main();
